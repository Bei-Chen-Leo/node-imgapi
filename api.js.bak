'use strict';

const express = require('express');
const fs = require('fs/promises');
const path = require('path');
const { createClient } = require('redis');

// 时间格式化
const formatTime = date =>
  new Intl.DateTimeFormat('zh-CN', {
    timeZone: 'Asia/Shanghai',
    year: 'numeric',
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit',
    hour12: false
  })
    .format(date)
    .replace(/\//g, '-')
    .replace(/,/g, '');

module.exports = (config) => {
  const router = express.Router();
  const { dir: dirConfig, cache: cacheConfig, update: updateConfig } = config;
  const IMG_DIR = dirConfig.imgDir;
  const USE_REDIS = cacheConfig.redisEnable;
  const MAX_CACHE = cacheConfig.mapMaxSize || 100;
  const REDIS_TTL = cacheConfig.redisTTL || 3600 * 1000; // ms
  const UPDATE_INTERVAL = (updateConfig.updateHours || 6) * 3600 * 1000;

  // CORS
  router.use((req, res, next) => {
    res.header('Access-Control-Allow-Origin', '*');
    res.header('Access-Control-Allow-Methods', 'GET,OPTIONS');
    res.header('Access-Control-Allow-Headers', 'Content-Type');
    if (req.method === 'OPTIONS') return res.sendStatus(204);
    next();
  });

  // Redis init
  let redisClient = null, redisHealthy = false;
  if (USE_REDIS) {
    redisClient = createClient({ 
      socket: { host: cacheConfig.redisHost, port: cacheConfig.redisPort },
      password: cacheConfig.redisPassword
    });
    redisClient.on('connect', () => { redisHealthy = true; console.log(`[Redis] connected`); });
    redisClient.on('error', () => { redisHealthy = false; });
    redisClient.connect().catch(() => {});
  }

  // LRU 缓存：path → info
  const fileCache = new Map();

  // 目录索引：dirPath → [{ path, size, mtime, relPath }]
  const dirIndex = new Map();
  let isScanning = false;

  // 递归扫描并收集 metadata
  async function scanAndIndex() {
    if (isScanning) return;
    isScanning = true;
    console.log(`[Index] scanning ${IMG_DIR} ...`);
    const newIndex = new Map();

    async function walk(dir) {
      const entries = await fs.readdir(dir, { withFileTypes: true });
      await Promise.all(entries.map(async e => {
        const full = path.join(dir, e.name);
        if (e.isDirectory()) {
          await walk(full);
        } else if (/\.(jpe?g|png|gif|webp)$/i.test(e.name)) {
          const stats = await fs.stat(full);
          const rel = path.relative(IMG_DIR, full).replace(/\\/g, '/');
          const info = {
            path: full,
            size: stats.size,
            mtime: stats.mtime.getTime(),
            relPath: '/api/' + rel
          };
          const parent = path.dirname(full);
          if (!newIndex.has(parent)) newIndex.set(parent, []);
          newIndex.get(parent).push(info);
        }
      }));
    }

    await walk(IMG_DIR);
    dirIndex.clear();
    for (const [dir, infos] of newIndex) {
      dirIndex.set(dir, infos);
    }
    console.log(`[Index] done, ${[...dirIndex.values()].flat().length} files indexed`);
    isScanning = false;
  }

  // 定时重扫
  if (UPDATE_INTERVAL > 0) {
    setInterval(() => { if (!isScanning) scanAndIndex(); }, UPDATE_INTERVAL).unref();
  }
  scanAndIndex();

  // 随机获取文件元信息（不再 stat）
  async function getFileInfo(infoObj, ip = 'unknown') {
    const key = `img:${infoObj.path}`;
    const useRedis = USE_REDIS && redisHealthy;
    const isProd = process.env.NODE_ENV === 'production';

    // Redis 缓存
    if (useRedis) {
      const cached = await redisClient.get(key);
      if (cached) return JSON.parse(cached);
    }
    // 本地 LRU
    if (fileCache.has(infoObj.path)) {
      const cached = fileCache.get(infoObj.path);
      fileCache.delete(infoObj.path);
      fileCache.set(infoObj.path, cached);
      return cached;
    }

    // 构造返回对象
    const result = {
      filename: path.basename(infoObj.path),
      size: infoObj.size,
      mtime: infoObj.mtime,
      path: infoObj.relPath
    };

    // 写回缓存
    if (useRedis) {
      await redisClient.setEx(key, REDIS_TTL/1000, JSON.stringify(result));
    } else {
      fileCache.set(infoObj.path, result);
      if (fileCache.size > MAX_CACHE) {
        const oldest = fileCache.keys().next().value;
        fileCache.delete(oldest);
      }
    }
    return result;
  }

  // 主路由
  router.get('/*', async (req, res, next) => {
    try {
      const wantJson = req.query.json === '1';
      const rel = (req.params[0] || '').replace(/^\/+/, '');
      const ip = (req.headers['x-forwarded-for'] || req.ip).split(',')[0].trim();

      // 根目录随机
      if (!rel) {
        if (dirIndex.size === 0) await scanAndIndex();
        const dirs = Array.from(dirIndex.keys());
        const pickDir = dirs[Math.floor(Math.random() * dirs.length)];
        const files = dirIndex.get(pickDir);
        const infoObj = files[Math.floor(Math.random() * files.length)];
        const info = await getFileInfo(infoObj, ip);

        // 统一加 Cache-Control
        const opts = { maxAge: 86400000, dotfiles: 'ignore' };
        return wantJson
          ? res.json(info)
          : res.sendFile(infoObj.path, opts);
      }

      // 指定路径
      const abs = path.join(IMG_DIR, rel);
      const infos = dirIndex.get(abs);
      if (infos && infos.length) {
        // 指定目录随机
        const infoObj = infos[Math.floor(Math.random() * infos.length)];
        const info = await getFileInfo(infoObj, ip);
        const opts = { maxAge: 86400000, dotfiles: 'ignore' };
        return wantJson
          ? res.json(info)
          : res.sendFile(infoObj.path, opts);
      }

      // 单文件直出
      // 如果不是目录，就当文件看
      const all = [...dirIndex.values()].flat();
      const single = all.find(o => path.relative(IMG_DIR, o.path) === rel);
      if (single) {
        const info = await getFileInfo(single, ip);
        const opts = { maxAge: 86400000, dotfiles: 'ignore' };
        return wantJson
          ? res.json(info)
          : res.sendFile(single.path, opts);
      }

      return res.status(404).send('未找到图片');
    } catch (err) {
      next(err);
    }
  });

  // 错误处理中间件
  router.use((err, req, res, next) => {
    console.error('[API Error]', err);
    res.status(500).send('服务器错误');
  });

  // 退出时清理
  process.on('SIGTERM', () => {
    if (redisClient && redisClient.isOpen) redisClient.quit().catch(()=>{});
  });

  return router;
};
